# Introduction

Simulation and optimization approaches are present in our everyday lives, albeit most of the time operating in a background plane. For example, 
when navigating with a GPS, the system simulates different routes and optimizes for the shortest or fastest path. 
Similarly, supply chains use optimization algorithms to minimize costs and maximize efficiency, while simulations help predict demand and manage 
inventory. These techniques are fundamental tools in decision-making processes across various industries, from transportation and logistics to finance and healthcare.

But what do simulation and optimization approaches have in common, apart from being complementary tools? The answer lies in the concept of a *model*. In the context
of machine learning, we normally refer to a model as a mathematical or computational representation that captures the relationships between input data and output predictions. 
In simulation and optimization, a model similarly serves as an abstraction of a real-world system or process, allowing us to analyze, predict, and improve its behavior 
through experimentation and algorithmic techniques.

In the following, we will delve deeper into the concept of a model and how models are used in simulation and optimization contexts using some practical examples.

## Simulating supermarket dynamics

Imagine you are in your favourite grocery store waiting at the checkout queue. For simplicity, let's assume there is only one open counter. When you arrive at the queue, there might be other customers already 
waiting, while the first customer at the queue is currently being served. Shortly after you, a new customer arrives, taking the next free spot right 
behind you. And then another customer arrives, and another one, and another one... 

Let's try to break down how this system behaves and what are the most important interactions between the parts of the system. In general, 
we will distinguish between *components*, *states*, *events*, *inputs* and *metrics*. 

- **Components:** These are the entities that interact with each other. In our example, we have customers, cashiers and the queue itself.
- **States:** The configurations of the system that represent valid combinations of specific properties of the components at a given moment 
of time. For instance, at each time the queue has a specific length: zero if it's empty, one customer, two customers, etc. Additionally, the cashier 
can be busy or idle. We can also count the number of customers currently present in the supermarket which have not yet arrive at the checkout queue.
- **Events:** The interactions themselves, like a new customer arriving at the queue, checkout start or checkout completion.
- **Inputs:** Whatever information is fed into the system, e.g. arrival times, service times, etc. These inputs can contain statistical assumptions, like
the distribution of arrival times.
- **Metrics:** How we evaluate the system as a whole in a given time step. For instance, what is the average waiting time? How much time are the cashiers busy?
How is the queue length distributed? 

The system could be represented by the following Python code as a minimal variant. 

```python
import heapq, random

# event = (time, type, customer_id)
event_list = []
heapq.heappush(event_list, (first_arrival_time, 'arrival', 1))

while event_list and time < sim_end:
    time, ev_type, cid = heapq.heappop(event_list)
    if ev_type == 'arrival':
        if any_queue_free():
            start_checkout(cid, time)
            heapq.heappush(event_list, (time + service_time(cid), 'departure', cid))
        else:
            enqueue(cid, time)
        heapq.heappush(event_list, (time + next_interarrival(), 'arrival', next_id()))
    elif ev_type == 'departure':
        finish_service(cid, time)
        if queue_not_empty():
            next_cid = dequeue()
            start_service(next_cid, time)
            heapq.heappush(event_list, (time + service_time(next_cid), 'departure', next_cid))
```

This code assumes that customers arrive at regular subsequent intervals after each arrival event. The parameter ``sim_end`` defines 
how long (how many steps) we want to simulate in this case. The function ``service_time`` returns the time the cashier needs 
for checking out customer ``cid``. The next customer will arrive after a time given by the function ``next_interarrival``, which 
can implement different stochastic behaviours.

![](figures/fig_intro_1_cropped)

In this figure, $s_{ik}$ denotes the time spent serving customer $k$ by cashier $i$, and $a_{ik}$ denotes the arrival time of customer 
$k$ at the queue served by cashier $i$.
